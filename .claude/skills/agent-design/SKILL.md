---
name: agent-design
description: AI Agent設計のベストプラクティスを適用して、効果的なマルチエージェントシステムやワークフローを設計する。ユーザーが「エージェントを設計して」「エージェントシステムを改善して」「ワークフローパターンを提案して」と依頼した時、またはAI Agent設計について質問した時に使用する。
---

# AI Agent設計スキル

## 概要

### AI Agent設計とは

AI Agentとは、Large Language Model (LLM) を活用して自律的にタスクを実行するシステムである。単一のプロンプトでは解決困難な複雑なタスクを、計画、実行、評価のサイクルを通じて段階的に達成する。

エージェントシステムの主要な特徴：

- **自律性**: タスク達成に必要なステップを動的に決定する
- **ツール使用**: 外部API、データベース、検索エンジンなどを活用する
- **状態管理**: コンテキストと中間結果を保持する
- **反復改善**: 出力を評価し、必要に応じて再実行する

### なぜ重要か

AI Agent設計は以下の価値を提供する：

**複雑タスクの分解**
単一のモノリシックなプロンプトでは制御困難なタスクを、管理可能な小さなステップに分割できる。各ステップは独立してテスト・改善可能である。

**スケーラビリティ**
ワークフローパターンを適用することで、並列化やタスク分散が可能になる。処理時間の短縮とスループットの向上を実現できる。

**保守性と拡張性**
モジュール化された設計により、部分的な修正や機能追加が容易になる。システム全体を再設計することなく改善を積み重ねられる。

**透明性とデバッグ容易性**
各ステップの入出力を明示的に管理することで、問題の特定と修正が容易になる。

### 適用場面

AI Agent設計が特に有効な場面：

- 複数のステップを要する複雑なタスク（コード生成、データ分析、レポート作成）
- 外部ツールやAPIとの連携が必要なタスク
- 反復的な改善や評価が必要なタスク
- 入力に応じて異なる処理フローが必要なタスク
- 複数のタスクを並列実行することで効率化できる場合

## 基本原則

### 1. シンプリシティ優先

**原則**
常にシンプルなソリューションから始める。複雑性は、実測で改善が確認できる場合のみ追加する。

**実践ガイド**
- 単一のプロンプトで解決できないか検証する
- 必要最小限のワークフローから開始する
- 各ステップの必要性を実データで検証する
- 複雑なマルチエージェントシステムは最後の選択肢とする

**理由**
不要な複雑性はデバッグを困難にし、レイテンシとコストを増大させる。多くの場合、適切に設計された単一プロンプトや簡素なプロンプト連鎖で十分である。

### 2. 透明性とデバッグ容易性

**原則**
各ステップの入出力を明示的に記録し、システムの動作を追跡可能にする。

**実践ガイド**
- 各エージェント呼び出しの入力と出力をログに記録する
- 中間ステップを可視化する
- エラー発生時のコンテキストを保存する
- 計画ステップを明示する（thinking tagsの使用など）

**理由**
問題の特定と修正には、システムの内部状態を観察できることが不可欠である。透明性の高い設計は、改善サイクルを加速する。

### 3. モジュール性と再利用性

**原則**
各コンポーネントを独立した機能単位として設計し、再利用可能にする。

**実践ガイド**
- 単一責任の原則を適用する（各エージェントは1つの明確な役割を持つ）
- 共通機能を抽出し、複数のワークフローで再利用する
- インターフェースを明確に定義する
- 疎結合を維持する

**理由**
モジュール化により、システムの一部を独立して改善・テストできる。新しいユースケースへの拡張も容易になる。

## ワークフローパターン（優先順位順）

### 1. プロンプト連鎖（Prompt Chaining）

**概要**
タスクを順序立てたステップに分解し、各ステップの出力を次のステップの入力とする。最もシンプルで理解しやすいパターンである。

**使用場面**
- ステップが明確に定義できるタスク
- 各ステップが前のステップの出力に依存するタスク
- デバッグと改善を段階的に行いたい場合

**簡単な例**
```
ステップ1: ユーザーの質問を分析し、必要な情報を特定する
  入力: ユーザーの質問
  出力: 必要な情報のリスト

ステップ2: 各情報を検索ツールで取得する
  入力: 情報のリスト
  出力: 検索結果

ステップ3: 検索結果を基に回答を生成する
  入力: ユーザーの質問 + 検索結果
  出力: 最終回答
```

**利点**
- 実装がシンプルで理解しやすい
- 各ステップを独立してテスト・改善できる
- デバッグが容易

**制約**
- ステップが多いとレイテンシが増加する
- 並列化できない

### 2. ルーティング（Routing）

**概要**
入力を分類し、特化したタスクやプロンプトに振り分ける。異なるタイプの入力に対して最適化された処理を適用できる。

**使用場面**
- 入力タイプが多様なタスク（カスタマーサポート、コンテンツ分類）
- 各タイプに特化した処理が必要な場合
- 複雑度やコストを入力に応じて最適化したい場合

**簡単な例**
```
入力: ユーザーの問い合わせ

ルーター: 問い合わせタイプを分類
  → "技術的な質問" → 技術サポート専用プロンプト
  → "請求関連" → 請求処理専用プロンプト
  → "一般的な質問" → 汎用FAQ処理
```

**利点**
- 各タイプに最適化された処理を適用できる
- シンプルな問い合わせには軽量なモデルを使用してコスト削減
- 特化したプロンプトにより精度向上

**制約**
- ルーティングロジックの精度が重要
- 誤分類のハンドリングが必要

### 3. 並列化（Parallelization）

**概要**
独立した複数のタスクを同時実行し、結果を統合する。レイテンシの大幅な削減が可能である。

**使用場面**
- 独立した複数のサブタスクに分割できるタスク
- 各サブタスクの実行時間が長い場合
- リアルタイム性が求められるタスク

**簡単な例**
```
入力: 複数のドキュメント

並列実行:
  タスクA: ドキュメント1を要約
  タスクB: ドキュメント2を要約
  タスクC: ドキュメント3を要約

統合: すべての要約を結合して最終レポートを生成
```

**利点**
- レイテンシの大幅削減（N個のタスクを1つ分の時間で実行）
- スループット向上

**制約**
- タスクが独立している必要がある
- コストはシーケンシャル実行と変わらない

### 4. オーケストレーター・ワーカー（Orchestrator-Workers）

**概要**
中央のLLM（オーケストレーター）がタスクを動的に分解し、専用のワーカーエージェントに委譲する。複雑なタスクや予測困難なワークフローに対応できる。

**使用場面**
- タスクの構造が入力によって大きく変わる場合
- 事前にステップを定義できない複雑なタスク
- 動的なツール選択や条件分岐が必要な場合

**簡単な例**
```
入力: 複雑な調査タスク

オーケストレーター:
  1. タスク全体を分析
  2. 必要なサブタスクを動的に決定
  3. 各サブタスクを適切なワーカーに委譲
  4. ワーカーの結果を統合
  5. 追加のサブタスクが必要か判断

ワーカー例:
  - データ収集ワーカー
  - データ分析ワーカー
  - レポート生成ワーカー
```

**利点**
- 複雑で予測困難なタスクに対応できる
- 動的なワークフロー生成
- 専門化されたワーカーによる高品質な出力

**制約**
- 複雑性が高く、デバッグが困難
- レイテンシとコストが増加
- オーケストレーターの性能がシステム全体に影響

### 5. 評価者・最適化者（Evaluator-Optimizer）

**概要**
出力を評価し、基準を満たすまで反復的に改善する。品質が重要なタスクに有効である。

**使用場面**
- 出力の品質基準が明確なタスク
- 初回の出力が不十分な可能性が高い場合
- 反復的な改善によって品質が向上するタスク

**簡単な例**
```
ステップ1: 初期出力を生成

ステップ2: 評価者が出力を評価
  - 基準を満たしているか確認
  - 改善点を特定

ステップ3: 最適化者が改善を実行
  - 評価者のフィードバックを基に修正

ステップ4: 基準を満たすまでステップ2-3を繰り返す
```

**利点**
- 出力品質の向上
- 明確な評価基準の適用
- 段階的な改善

**制約**
- コストとレイテンシの増加（反復回数に比例）
- 評価基準の設計が重要
- 無限ループのリスク（最大反復回数の設定が必要）

## クイックチェックリスト

### エージェント設計時の確認項目

**基本設計**
- [ ] 単一のプロンプトで解決できないか検証したか？
- [ ] 最もシンプルなワークフローパターンを選択したか？
- [ ] 各ステップの必要性を実データで検証したか？
- [ ] システムの動作を追跡可能にしているか？

**ワークフロー選択**
- [ ] タスクの構造は予測可能か？→ プロンプト連鎖
- [ ] 入力タイプが多様か？→ ルーティング
- [ ] 独立したサブタスクがあるか？→ 並列化
- [ ] タスク構造が動的に変わるか？→ オーケストレーター・ワーカー
- [ ] 反復的な改善が必要か？→ 評価者・最適化者

**ツール統合**
- [ ] 必要なツールを明確に定義したか？
- [ ] ツールの説明は明確か？
- [ ] エラーハンドリングを実装したか？
- [ ] ツール呼び出しのコストを考慮したか？

**評価とテスト**
- [ ] 評価メトリクスを定義したか？
- [ ] テストデータセットを用意したか？
- [ ] ベースラインと比較したか？
- [ ] エラーケースをカバーしたか？

**本番運用**
- [ ] ログとモニタリングを実装したか？
- [ ] エラーハンドリングとリトライ戦略を定義したか？
- [ ] コストとレイテンシを測定したか？
- [ ] スケーラビリティを考慮したか？

## 詳細リファレンス

より詳細な情報は、以下のリファレンスを参照すること：

### アーキテクチャと原則
[references/architecture-principles.md](references/architecture-principles.md)
- エージェント設計の基本原則の詳細解説
- シンプリシティ、透明性、モジュール性の実践方法
- Before/After形式の改善例

### ワークフローパターン詳細
[references/workflow-patterns-detail.md](references/workflow-patterns-detail.md)
- 5つのワークフローパターンの詳細実装ガイド
- パラメータ設定とユースケース
- パターン選択ガイド

### ツール統合
[references/tool-integration.md](references/tool-integration.md)
- ツールの選択基準と最適化
- エラーハンドリングのベストプラクティス
- ツールチェーンの設計

### 評価とテスト
[references/evaluation-testing.md](references/evaluation-testing.md)
- 評価方法（コードベース、モデルベース、ヒューマングレーダー）
- 重要メトリクスとテスト戦略
- 継続的な改善アプローチ

### アンチパターン
[references/anti-patterns.md](references/anti-patterns.md)
- よくある設計ミスと回避方法
- エラー伝播、プロンプト脆性、マルチエージェント調整失敗
- 各アンチパターンのBefore/After例

### 本番運用
[references/production-best-practices.md](references/production-best-practices.md)
- モニタリングとロギング
- エラーハンドリングとリトライ戦略
- コスト最適化とレイテンシ改善

## 実装例

実際の改善例とユースケース別の実装は、以下を参照すること：

### Before/After改善例
[examples/before-after-examples.md](examples/before-after-examples.md)
- ワークフロー設計の改善例（6-8例）
- シンプルな設計から高度な設計への進化
- 各改善の効果測定

### ワークフローパターン実装例
[examples/workflow-patterns.md](examples/workflow-patterns.md)
- 5つのパターンの詳細実装例
- 擬似コードと実装ステップ
- パラメータ設定の具体例

### ユースケース別実装例
[examples/use-case-examples.md](examples/use-case-examples.md)
- コード生成エージェント
- データ分析エージェント
- カスタマーサポートエージェント
- コンテンツ生成エージェント
- 研究・調査エージェント
- タスク自動化エージェント

## 使用方法

### 自動発動

このスキルは以下の場合に自動的にロードされる：

- ユーザーが「エージェントを設計して」と依頼した時
- ユーザーが「エージェントシステムを改善して」と依頼した時
- ユーザーが「ワークフローパターンを提案して」と依頼した時
- ユーザーがAI Agent設計について質問した時

### 手動呼び出し

スキルを明示的に呼び出すには、以下のコマンドを使用する：

```
/agent-design
```

## エージェント設計の実践手順

### 1. ユーザーの要求を分析

以下を特定する：

- タスクの目的と期待される出力
- 入力データの種類と構造
- 必要な外部ツールやAPI
- 品質基準とパフォーマンス要件
- 制約条件（レイテンシ、コスト、精度）

### 2. 適切なワークフローパターンを選択

タスクの特性に基づいて最適なパターンを選択する：

1. **シンプリシティ優先**: まず単一プロンプトで解決できないか検討
2. **ステップが明確**: プロンプト連鎖
3. **入力タイプが多様**: ルーティング
4. **独立したサブタスク**: 並列化
5. **動的なワークフロー**: オーケストレーター・ワーカー
6. **反復的な改善**: 評価者・最適化者

### 3. 設計案を提案（Before/After形式）

現在の設計（または想定される初期設計）と改善後の設計を明示する：

```markdown
### Before (現在の設計)
[現在の問題点を含む設計]

### After (改善後の設計)
[ワークフローパターンを適用した設計]

### 改善ポイント
- 改善点1: 具体的な効果
- 改善点2: 具体的な効果
- 改善点3: 具体的な効果
```

### 4. 実装の詳細を提供

選択したワークフローパターンに基づいて：

- 各ステップの入出力を明確に定義
- 使用するツールとその役割を説明
- エラーハンドリング戦略を提案
- 評価メトリクスを定義

### 5. 必要に応じて詳細リファレンスを提供

ユーザーの理解度や要求の複雑性に応じて、関連する詳細リファレンスや実装例へのリンクを提示する。

## 重要な注意事項

### シンプリシティを重視

複雑なマルチエージェントシステムは最後の手段である。多くの場合、適切に設計された単一プロンプトや簡素なプロンプト連鎖で十分な結果が得られる。

### 実測に基づく改善

理論的な複雑性の追加ではなく、実際のデータとメトリクスに基づいて改善を判断する。改善が測定可能な効果をもたらすことを確認する。

### 反復的なテスト

各ステップを独立してテストし、全体のワークフローを段階的に構築する。問題の早期発見と修正を可能にする。

### タスクに応じた選択

すべてのタスクに同じパターンを適用するのではなく、タスクの特性に応じて最適なパターンを選択する。パターンの組み合わせも検討する。
